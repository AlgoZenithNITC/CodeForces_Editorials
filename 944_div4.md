## A. My First Sorting Problem

<details>
<summary>Python</summary>

```python
for _ in range(int(input())):
    n,m = map(int,input().split())
    print(min(n,m),end = ' ')
    print(max(n,m))

```

</details>

<details>
<summary>Cpp</summary>

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, m;
        cin >> n >> m;
        cout << min(n, m) << " " << max(n, m) << endl;
    }
    return 0;
}

```

</details>

<details>
<summary>Java</summary>

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        while (t-- > 0) {
            int n = scanner.nextInt();
            int m = scanner.nextInt();
            System.out.println(Math.min(n, m) + " " + Math.max(n, m));
        }
    }
}

```

</details>

## Question - 2

<details>
<summary>Python</summary>

```python

```

</details>

<details>
<summary>Cpp</summary>

```cpp

```

</details>

<details>
<summary>Java</summary>

```java

```

</details>

## Question - 3

<details>
<summary>Python</summary>

```python

```

</details>

<details>
<summary>Cpp</summary>

```cpp

```

</details>

<details>
<summary>Java</summary>

```java

```

</details>

## D. Binary Cut

<details>
<summary>Python</summary>

```python
for _ in range(int(input())):
    s = input()
    flag = 0
    cnt = 1
    for i in range(1,len(s)):
        if s[i-1]!=s[i]:
            cnt+=1
        if s[i-1] == '0' and s[i] == '1':
            flag = 1
    print(cnt-flag)
```

</details>

<details>
<summary>Cpp</summary>

```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        string s;
        cin >> s;
        int flag = 0;
        int cnt = 1;
        for (int i = 1; i < s.length(); ++i) {
            if (s[i - 1] != s[i]) {
                cnt++;
            }
            if (s[i - 1] == '0' && s[i] == '1') {
                flag = 1;
            }
        }
        cout << cnt - flag << endl;
    }
    return 0;
}

```

</details>

<details>
<summary>Java</summary>

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        scanner.nextLine(); // consume the newline after the integer
        while (t-- > 0) {
            String s = scanner.nextLine();
            int flag = 0;
            int cnt = 1;
            for (int i = 1; i < s.length(); i++) {
                if (s.charAt(i - 1) != s.charAt(i)) {
                    cnt++;
                }
                if (s.charAt(i - 1) == '0' && s.charAt(i) == '1') {
                    flag = 1;
                }
            }
            System.out.println(cnt - flag);
        }
    }
}

```

</details>

## E. Find the Car

<details>
<summary>Python</summary>

```python
def solve():
    n, k, q = map(int, input().split())
    a = [0] * (k + 1)
    b = [0] * (k + 1)
    a[0] = 0
    b[0] = 0

    for i in range(1, k + 1):
        a[i] = int(input())
    for i in range(1, k + 1):
        b[i] = int(input())

    for i in range(q):
        c = int(input())
        l = 0
        r = k

        # Potential optimization: Early termination if c is less than the first element
        if c < a[1]:
            print(b[0], end=" ")
            continue

        while l <= r:
            mid = (l + r) // 2
            if a[mid] > c:
                r = mid - 1
            else:
                l = mid + 1
        if a[r] == c:
            ans = b[r]
        else:
            ans = b[r] + (c - a[r]) * (b[r + 1] - b[r]) / (a[r + 1] - a[r])
        print(ans, end=" ")
    print()

t = int(input())
while t > 0:
    solve()
    t -= 1

```

</details>

<details>
<summary>Cpp</summary>

```cpp
#include <bits/stdc++.h>
using namespace std;
 
void solve()
{
    int n, k, q;
    cin >> n >> k >> q;
    vector<long long> a(k+1), b(k+1);
    a[0] = 0;
    b[0] = 0;
    for(int i = 1; i <= k; i++)
    {
        cin >> a[i];
    }
    for(int i = 1; i <= k; i++)
    {
        cin >> b[i];
    }
    for(int i = 0; i < q; i++)
    {
        long long c;
        cin >> c;
        int l = 0, r = k;
        while(l <= r)
        {
            int mid = l+r>>1;
            if(a[mid] > c)
            {
                r = mid-1;
            }
            else
            {
                l = mid+1;
            }
        }
        if(a[r] == c)
        {
            cout << b[r] << " ";
            continue;
        }
        long long ans = b[r] + (c-a[r])*(b[r+1]-b[r])/(a[r+1]-a[r]);
        cout << ans << " ";
    }
    cout << endl;
}
 
int main(){
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```

</details>

<details>
<summary>Java</summary>

```java
import java.util.Scanner;

public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();

        while (t-- > 0) {
            int n = scanner.nextInt(); // Potentially unused variable 'n'
            int k = scanner.nextInt();
            int q = scanner.nextInt();

            long[] a = new long[k + 1];
            long[] b = new long[k + 1];

            a[0] = 0;
            b[0] = 0;

            for (int i = 1; i <= k; i++) {
                a[i] = scanner.nextLong();
            }

            for (int i = 1; i <= k; i++) {
                b[i] = scanner.nextLong();
            }

            for (int i = 0; i < q; i++) {
                long c = scanner.nextLong();
                int l = 0, r = k;

                // Potential optimization: Early termination if c is less than the first element
                if (c < a[1]) {
                    System.out.print(b[0] + " ");
                    continue;
                }

                while (l <= r) {
                    int mid = l + (r - l) / 2;
                    if (a[mid] > c) {
                        r = mid - 1;
                    } else {
                        l = mid + 1;
                    }
                }

                long ans;
                if (a[r] == c) {
                    ans = b[r];
                } else {
                    ans = b[r] + (c - a[r]) * (b[r + 1] - b[r]) / (a[r + 1] - a[r]);
                }

                System.out.print(ans + " ");
            }
            System.out.println();
        }
    }
}

```

</details>

## F. Circle Perimeter

<details>
<summary>Python</summary>

```python
def solve():
  r = int(input())
  height = r
  ans = 0

  # Iterate over possible x coordinates (0 to r)
  for i in range(r + 1):
    # Decrease height as long as it satisfies the condition
    while i * i + height * height >= (r + 1) * (r + 1):
      height -= 1
    # Copy height to avoid modifying the original value
    current_height = height
    # Count possible y coordinates for current x
    while i * i + current_height * current_height >= r * r and current_height > 0:
      current_height -= 1
      ans += 1

  # Multiply by 4 for all quadrants
  print(ans * 4)

t = int(input())
while t > 0:
  solve()
  t -= 1
```

</details>

<details>
<summary>Cpp</summary>

```cpp
#include <iostream>
using namespace std;
 
void solve()
{
    long long r;
    cin >> r;
    /**
     * Approach :
     * --------
     * 
     * We find the no. of points in a quadrant(specially the positive quadrant)
     * 
     * 
     * Multiply it by 4 for the answer
     * 
     */
    long long height = r;
    long long ans = 0;

    /**
     * iterate over all possible positive x coordinates and 
     * find the no. of y's possible respective to each of these
     * 
     * Start with a point that satisfies the given conditions (r <= dist < r + 1)
     * 
     * (0, r) - since the boundary point (0, r + 1) doesnot satisfy the conditions
     * Next immediate possibility among integers for y coordinate is r i.e (0, r)
     * 
     * 0, height
     * 
     * now we keep on reducing the height to know all possible values for a corresponding x
     * if it's a solution we increment answer count
     * 
     * else we proceed to next x coordinate
     */
    for(long long i = 0; i <= r; i++)
    {
        while(i*i + height*height >= (r+1)*(r+1))
        {
            height--;
        }
        long long cop = height;
        while(i*i+cop*cop >= r*r && cop > 0)
        {
            cop--;
            ans++;
        }
    }
    cout << ans*4 << endl;
}
 
int main(){
    int t = 1;
    cin >> t;
    while (t--) {
        solve();
    }
}
```

</details>

<details>
<summary>Java</summary>

```java
import java.util.Scanner;

public class Solution {
  public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    int t = scanner.nextInt();

    while (t-- > 0) {
      long long r = scanner.nextLong();
      long long height = r;
      long long ans = 0;

      // Iterate over possible x coordinates (0 to r)
      for (long long i = 0; i <= r; i++) {
        // Decrease height as long as it satisfies the condition
        while (i * i + height * height >= (r + 1) * (r + 1)) {
          height--;
        }
        // Copy height to avoid modifying the original value
        long long currentHeight = height;
        // Count possible y coordinates for current x
        while (i * i + currentHeight * currentHeight >= r * r && currentHeight > 0) {
          currentHeight--;
          ans++;
        }
      }
      // Multiply by 4 for all quadrants
      System.out.println(ans * 4);
    }
  }
}
```

</details>
